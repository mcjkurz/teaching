<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>2D Principal Component Analysis (PCA)</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady();
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* =========================================
           BASE STYLES
           ========================================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            font-size: 14px;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        header {
            margin-bottom: 2rem;
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #2c3e50;
        }

        header p {
            font-size: 0.95rem;
            color: #666;
        }

        /* =========================================
           BUTTONS
           ========================================= */
        .btn {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: #f8f9fa;
            border-color: #aaa;
        }

        .btn.primary {
            background: #3498db;
            border-color: #3498db;
            color: white;
        }

        .btn.primary:hover {
            background: #2980b9;
        }

        .btn.success {
            background: #27ae60;
            border-color: #27ae60;
            color: white;
        }

        .btn.success:hover {
            background: #219a52;
        }

        .btn.danger {
            background: #e74c3c;
            border-color: #e74c3c;
            color: white;
        }

        .btn.danger:hover {
            background: #c0392b;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.large {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 500;
        }

        .btn.toggle {
            background: #8e44ad;
            border-color: #8e44ad;
            color: white;
            min-width: 140px;
        }

        .btn.toggle:hover {
            background: #732d91;
        }

        .btn.toggle.active {
            background: #27ae60;
            border-color: #27ae60;
        }

        .btn.toggle.active:hover {
            background: #219a52;
        }

        /* =========================================
           STEP SECTIONS
           ========================================= */
        .step-section {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }

        .step-section.hidden {
            display: none;
        }

        .step-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1rem;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .step-badge {
            background: #27ae60;
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .step-content {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        .step-canvas {
            flex: 0 0 320px;
        }

        .step-canvas canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
            display: block;
        }

        .step-explanation {
            flex: 1;
            min-width: 320px;
            overflow-x: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Data controls */
        .data-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .point-counter {
            font-size: 0.9rem;
            color: #666;
            margin-left: auto;
        }

        .data-table {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 1rem;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .data-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th, .data-table td {
            padding: 0.3rem 0.5rem;
            text-align: right;
            border-bottom: 1px solid #e0e0e0;
        }

        .data-table th {
            font-weight: 600;
            color: #555;
        }

        /* Explanation boxes */
        .explanation-box {
            background: #f0f4f8;
            border-left: 4px solid #3498db;
            color: #2c3e50;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .explanation-box h4 {
            font-size: 0.95rem;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .explanation-box p {
            font-size: 0.9rem;
            color: #444;
        }

        .insight-box {
            background: #fef9e7;
            border-left: 4px solid #f39c12;
            color: #2c3e50;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .insight-box h4 {
            font-size: 0.95rem;
            margin-bottom: 0.5rem;
            color: #d68910;
        }

        .insight-box p, .insight-box li {
            font-size: 0.85rem;
            color: #555;
        }

        .insight-box ul {
            margin-left: 1.2rem;
            margin-top: 0.5rem;
        }

        .insight-box li {
            margin-bottom: 0.3rem;
        }

        .concept-box {
            background: #eaf2f8;
            border-left: 4px solid #2980b9;
            color: #2c3e50;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .concept-box h4 {
            font-size: 0.95rem;
            margin-bottom: 0.5rem;
            color: #2980b9;
        }

        .concept-box p {
            font-size: 0.85rem;
            color: #444;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .math-section {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            overflow-x: auto;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .math-section h4 {
            font-size: 0.95rem;
            color: #2c3e50;
            margin-bottom: 0.75rem;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 0.5rem;
        }

        .math-content {
            font-size: 0.9rem;
            line-height: 1.8;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .math-formula {
            text-align: center;
            margin: 0.75rem 0;
            overflow-x: auto;
        }

        .computed-value {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            margin: 0.5rem 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .highlight-pc1 {
            color: #e74c3c;
            font-weight: 600;
        }

        .highlight-pc2 {
            color: #9b59b6;
            font-weight: 600;
        }

        .highlight-result {
            background: #e8f4fd;
            border-color: #3498db;
        }

        /* Continue button container */
        .continue-container {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
            text-align: center;
        }

        /* Canvas controls */
        .canvas-controls {
            margin-top: 0.75rem;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 0.75rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: #555;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-line {
            width: 18px;
            height: 3px;
            border-radius: 2px;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        footer a {
            color: #3498db;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .step-canvas {
                flex: 1 1 100%;
            }

            .step-explanation {
                min-width: unset;
                max-width: 100%;
            }

            .concept-box p,
            .explanation-box p,
            .insight-box p,
            .math-content p {
                word-break: break-word;
                hyphens: auto;
            }

            .computed-value {
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>2D Principal Component Analysis (PCA)</h1>
            <p>A step-by-step interactive walkthrough of how PCA finds the directions of maximum variance</p>
        </header>

        <!-- STEP 0: Data Input -->
        <section class="step-section" id="step0Section">
            <h2><span class="step-badge">Step 0</span> Create Your Data</h2>
            <div class="data-controls">
                <button class="btn" id="btnRandom">Random</button>
                <button class="btn" id="btnCorrelated">Correlated</button>
                <button class="btn" id="btnNegCorrelated">Neg. Correlated</button>
                <button class="btn" id="btnCircular">Circular</button>
                <button class="btn danger" id="btnClear">Clear All</button>
                <span class="point-counter">Points: <strong id="pointCount">0</strong> (min. 3 required)</span>
            </div>
            <div class="step-content">
                <div class="step-canvas">
                    <canvas id="canvas0" width="320" height="320"></canvas>
                    <p style="font-size: 0.8rem; color: #666; margin-top: 0.5rem; text-align: center;">Click to add points</p>
                </div>
                <div class="step-explanation">
                    <div class="explanation-box">
                        <h4>Raw Data Points</h4>
                        <p>Click on the canvas to add data points, or use the preset buttons. PCA will find the directions along which your data varies the most.</p>
                    </div>
                    <div class="data-table" id="dataTable">
                        <table>
                            <thead>
                                <tr><th>Point</th><th>x</th><th>y</th></tr>
                            </thead>
                            <tbody id="dataTableBody">
                                <tr><td colspan="3" style="text-align: center; color: #999;">No data yet</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="continue-container">
                <button class="btn success large" id="btnStartStep1" disabled>
                    Continue to Step 1: Center the Data ‚Üí
                </button>
            </div>
        </section>

        <!-- STEP 1: Center Data -->
        <section class="step-section hidden" id="step1Section">
            <h2><span class="step-badge">Step 1</span> Center the Data</h2>
            <div class="step-content">
                <div class="step-canvas">
                    <canvas id="canvas1" width="320" height="320"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot" style="background: #bbb;"></div> Original</div>
                        <div class="legend-item"><div class="legend-dot" style="background: #3498db;"></div> Centered</div>
                        <div class="legend-item"><div class="legend-dot" style="background: none; border: 2px solid #e74c3c; width: 8px; height: 8px;"></div> Mean</div>
                    </div>
                    <div class="canvas-controls">
                        <button class="btn toggle" id="btnToggleStep1">Show Centering</button>
                    </div>
                </div>
                <div class="step-explanation">
                    <div class="explanation-box">
                        <h4>Why Center?</h4>
                        <p>We subtract the mean from each point so the data's centroid moves to the origin (0, 0). This ensures PCA finds directions of variance <em>from the center</em> of the data.</p>
                    </div>
                    <div class="math-section">
                        <h4>Computing the Mean</h4>
                        <div class="math-content">
                            <div class="math-formula">
                                $$\boldsymbol{\mu} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{x}_i = \begin{pmatrix} \bar{x} \\ \bar{y} \end{pmatrix}$$
                            </div>
                            <div class="computed-value highlight-result" id="meanComputed">
                                Computed mean: Œº = (?, ?)
                            </div>
                        </div>
                    </div>
                    <div class="math-section">
                        <h4>Centering Each Point</h4>
                        <div class="math-content">
                            <div class="math-formula">
                                $$\mathbf{x}_i^{\text{centered}} = \mathbf{x}_i - \boldsymbol{\mu}$$
                            </div>
                            <p style="font-size: 0.85rem; color: #666;">Each point is shifted so the new mean becomes (0, 0).</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="continue-container">
                <button class="btn success large" id="btnStartStep2">
                    Continue to Step 2: Compute Covariance ‚Üí
                </button>
            </div>
        </section>

        <!-- STEP 2: Covariance Matrix -->
        <section class="step-section hidden" id="step2Section">
            <h2><span class="step-badge">Step 2</span> Compute the Covariance Matrix</h2>
            <div class="step-content">
                <div class="step-canvas">
                    <canvas id="canvas2" width="320" height="320"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot" style="background: #3498db;"></div> Centered Data</div>
                        <div class="legend-item"><div class="legend-line" style="background: rgba(231,76,60,0.5);"></div> Var(x)</div>
                        <div class="legend-item"><div class="legend-line" style="background: rgba(155,89,182,0.5);"></div> Var(y)</div>
                        <div class="legend-item"><div class="legend-line" style="background: #f39c12;"></div> Cov slope</div>
                    </div>
                    <div class="canvas-controls">
                        <button class="btn toggle" id="btnToggleStep2">Show Variance</button>
                    </div>
                </div>
                <div class="step-explanation">
                    <div class="math-section" style="border-color: #3498db;">
                        <h4>The Covariance Matrix</h4>
                        <div class="math-content">
                            <!-- Visual matrix with color coding -->
                            <div style="display: flex; justify-content: center; margin: 1rem 0;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 1.5rem;">Œ£ =</span>
                                    <div style="display: flex; align-items: center;">
                                        <span style="font-size: 3rem; font-weight: 200;">(</span>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                                            <div style="background: #ffe6e6; padding: 8px 12px; border-radius: 4px; text-align: center; font-weight: 500; color: #c0392b;">Var(x)</div>
                                            <div style="background: #fff3e6; padding: 8px 12px; border-radius: 4px; text-align: center; font-weight: 500; color: #d68910;">Cov(x,y)</div>
                                            <div style="background: #fff3e6; padding: 8px 12px; border-radius: 4px; text-align: center; font-weight: 500; color: #d68910;">Cov(x,y)</div>
                                            <div style="background: #f3e6ff; padding: 8px 12px; border-radius: 4px; text-align: center; font-weight: 500; color: #8e44ad;">Var(y)</div>
                                        </div>
                                        <span style="font-size: 3rem; font-weight: 200;">)</span>
                                    </div>
                                </div>
                            </div>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin: 1rem 0;">
                                <div style="flex: 1; min-width: 200px; padding: 0.75rem; background: #ffe6e6; border-radius: 6px; border-left: 4px solid #e74c3c;">
                                    <strong style="color: #e74c3c;">Diagonal: Variance</strong><br>
                                    <span style="font-size: 0.85rem;">How much each variable spreads on its own axis</span>
                                    <ul style="font-size: 0.8rem; margin: 0.5rem 0 0 1rem; color: #555;">
                                        <li>Large Var(x) ‚Üí wide horizontal spread</li>
                                        <li>Large Var(y) ‚Üí wide vertical spread</li>
                                    </ul>
                                </div>
                                <div style="flex: 1; min-width: 200px; padding: 0.75rem; background: #fff3e6; border-radius: 6px; border-left: 4px solid #f39c12;">
                                    <strong style="color: #f39c12;">Off-diagonal: Covariance</strong><br>
                                    <span style="font-size: 0.85rem;">How variables move together</span>
                                    <ul style="font-size: 0.8rem; margin: 0.5rem 0 0 1rem; color: #555;">
                                        <li>Cov > 0 ‚Üí upward slope (‚Üó)</li>
                                        <li>Cov < 0 ‚Üí downward slope (‚Üò)</li>
                                        <li>Cov ‚âà 0 ‚Üí no relationship</li>
                                    </ul>
                                </div>
                            </div>
                            <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">The matrix is symmetric: Cov(x,y) = Cov(y,x). It encodes the "shape" of the data cloud.</p>
                        </div>
                    </div>
                    <div class="math-section">
                        <h4>Formula: How to Compute the Matrix</h4>
                        <div class="math-content">
                            <p style="font-size: 0.85rem; margin-bottom: 0.5rem;">The covariance matrix is built from <strong>outer products</strong> of centered vectors:</p>
                            <div class="math-formula">
                                $$\Sigma = \frac{1}{n-1} \sum_{i=1}^{n} (\mathbf{x}_i - \boldsymbol{\mu})(\mathbf{x}_i - \boldsymbol{\mu})^T$$
                            </div>
                            <p style="font-size: 0.85rem; color: #666; margin: 0.5rem 0;">For each point, we compute a 2√ó2 matrix (outer product), then average them:</p>
                            <div class="math-formula">
                                $$\begin{pmatrix} x_i \\ y_i \end{pmatrix} \begin{pmatrix} x_i & y_i \end{pmatrix} = \begin{pmatrix} x_i^2 & x_i y_i \\ y_i x_i & y_i^2 \end{pmatrix}$$
                            </div>
                            <p style="font-size: 0.85rem; color: #666;">Summing these matrices gives: diagonal = sum of squares (variance), off-diagonal = sum of products (covariance). Notice that $x_i y_i = y_i x_i$, so the covariance matrix is always <strong>symmetric</strong>.</p>
                        </div>
                    </div>
                    <div class="math-section">
                        <h4>Your Computed Covariance Matrix</h4>
                        <div class="math-content">
                            <div class="computed-value highlight-result" id="covMatrixComputed">
                                Œ£ = [ [?, ?], [?, ?] ]
                            </div>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem;">
                                <div class="computed-value" id="varXComputed" style="flex: 1;">Var(x) = ?</div>
                                <div class="computed-value" id="varYComputed" style="flex: 1;">Var(y) = ?</div>
                            </div>
                            <div class="computed-value" id="covXYComputed">Cov(x,y) = ?</div>
                            <div class="computed-value" id="covInterpretation" style="font-style: italic; background: #fffbe6; border-color: #ffe58f;">
                                Interpretation: ...
                            </div>
                        </div>
                    </div>

                    <!-- Interactive Covariance Explorer -->
                    <div class="insight-box" style="background: #f0f7ff; border-left-color: #3498db; margin-top: 1.5rem;">
                        <h4 style="color: #2980b9;">üéõÔ∏è Interactive: Explore the Covariance Matrix</h4>
                        <p style="margin-bottom: 0.5rem;">We can think of the covariance matrix as a <strong>transformation</strong> that shapes data. Starting from a circular cloud of points (Var(x)=Var(y)=1, Cov=0), the matrix stretches, squashes, and rotates it into an ellipse.</p>
                        <p id="covExplorerDataHint" style="margin-bottom: 1rem; padding: 0.5rem; background: #e8f4fc; border-radius: 4px; font-size: 0.85rem;"><strong>Your data:</strong> Var(x)=?, Var(y)=?, Cov=? ‚Äî try these values to see the transformation that produces your data's shape!</p>
                        
                        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-start;">
                            <div style="flex: 0 0 200px;">
                                <canvas id="covExplorerCanvas" width="200" height="200" style="border: 1px solid #ccc; border-radius: 6px; background: #fafafa;"></canvas>
                                <div style="text-align: center; font-size: 0.75rem; color: #666; margin-top: 0.25rem;">Ellipse shows 2œÉ contour</div>
                            </div>
                            
                            <div style="flex: 1; min-width: 220px;">
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 0.25rem;">
                                        <span style="color: #e74c3c; font-weight: 600;">Var(x)</span>
                                        <span id="varXSliderVal" style="font-family: monospace;">1.00</span>
                                    </label>
                                    <input type="range" id="varXSlider" min="0.1" max="3" step="0.01" value="1" 
                                        style="width: 100%; accent-color: #e74c3c;">
                                    <div style="font-size: 0.75rem; color: #888;">Horizontal spread</div>
                                </div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 0.25rem;">
                                        <span style="color: #9b59b6; font-weight: 600;">Var(y)</span>
                                        <span id="varYSliderVal" style="font-family: monospace;">1.00</span>
                                    </label>
                                    <input type="range" id="varYSlider" min="0.1" max="3" step="0.01" value="1" 
                                        style="width: 100%; accent-color: #9b59b6;">
                                    <div style="font-size: 0.75rem; color: #888;">Vertical spread</div>
                                </div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 0.25rem;">
                                        <span style="color: #f39c12; font-weight: 600;">Cov(x,y)</span>
                                        <span id="covXYSliderVal" style="font-family: monospace;">0.00</span>
                                    </label>
                                    <input type="range" id="covXYSlider" min="-3" max="3" step="0.01" value="0" 
                                        style="width: 100%; accent-color: #f39c12;">
                                    <div id="covRangeHint" style="font-size: 0.75rem; color: #888;">Valid range: [‚àí1.00, 1.00] ‚Äî variables can't co-vary more than they each vary on their own (Cov¬≤ ‚â§ Var(x)¬∑Var(y))</div>
                                </div>
                                
                                <div style="background: #fff; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; font-size: 0.8rem;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <span style="font-size: 1.1rem;">Œ£ =</span>
                                        <span style="font-size: 1.5rem; font-weight: 200;">(</span>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-family: monospace;">
                                            <span id="covMatDisplay00" style="background: #ffe6e6; padding: 2px 6px; border-radius: 2px; text-align: center;">1.00</span>
                                            <span id="covMatDisplay01" style="background: #fff3e6; padding: 2px 6px; border-radius: 2px; text-align: center;">0.00</span>
                                            <span id="covMatDisplay10" style="background: #fff3e6; padding: 2px 6px; border-radius: 2px; text-align: center;">0.00</span>
                                            <span id="covMatDisplay11" style="background: #f3e6ff; padding: 2px 6px; border-radius: 2px; text-align: center;">1.00</span>
                                        </div>
                                        <span style="font-size: 1.5rem; font-weight: 200;">)</span>
                                    </div>
                                    <div id="covExplorerInfo" style="margin-top: 0.5rem; color: #555; font-style: italic;">
                                        Equal variances, no correlation ‚Üí circular distribution
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="continue-container">
                <button class="btn success large" id="btnStartStep3">
                    Continue to Step 3: Find Principal Components ‚Üí
                </button>
            </div>
        </section>

        <!-- STEP 3: Eigenvalues, Eigenvectors & Ellipse (Combined) -->
        <section class="step-section hidden" id="step3Section">
            <h2><span class="step-badge">Step 3</span> Find Principal Components (Eigenvalues & Eigenvectors)</h2>
            <div class="step-content">
                <div class="step-canvas">
                    <canvas id="canvas3" width="320" height="320"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot" style="background: #3498db;"></div> Centered Data</div>
                        <div class="legend-item"><div class="legend-line" style="background: #e74c3c;"></div> PC1 (Œª‚ÇÅ)</div>
                        <div class="legend-item"><div class="legend-line" style="background: #9b59b6;"></div> PC2 (Œª‚ÇÇ)</div>
                        <div class="legend-item"><div class="legend-line" style="background: rgba(155,89,182,0.5); border: 1px dashed #9b59b6;"></div> Ellipse</div>
                    </div>
                    <div class="canvas-controls">
                        <button class="btn toggle" id="btnToggleStep3PC1">Show PC1</button>
                        <button class="btn toggle" id="btnToggleStep3PC2">Show PC2</button>
                        <button class="btn toggle" id="btnToggleStep3Ellipse">Show Ellipse</button>
                    </div>
                </div>
                <div class="step-explanation">
                    <div class="explanation-box">
                        <h4>The Goal: Find the Principal Components</h4>
                        <p>Principal components are the <strong>eigenvectors</strong> of the covariance matrix ‚Äî they point in the directions of maximum variance. But to find eigenvectors, we first need to find the <strong>eigenvalues</strong> (Œª). The eigenvalue tells us how much variance exists along its eigenvector. The largest eigenvalue's eigenvector becomes PC1.</p>
                    </div>
                    
                    <div class="math-section">
                        <h4>Step 3a: Set Up the Characteristic Equation</h4>
                        <div class="math-content">
                            <p style="font-size: 0.85rem; margin-bottom: 0.5rem;">An eigenvector v satisfies <strong>Œ£v = Œªv</strong>, which rearranges to <strong>(Œ£ - ŒªI)v = 0</strong>. For non-zero v to exist, the matrix (Œ£ - ŒªI) must be singular:</p>
                            <div class="math-formula">
                                $$\det(\Sigma - \lambda I) = 0$$
                            </div>
                            <p style="font-size: 0.85rem;">For our 2√ó2 covariance matrix:</p>
                            <div class="math-formula">
                                $$\det\begin{pmatrix} \text{Var}(x) - \lambda & \text{Cov}(x,y) \\ \text{Cov}(x,y) & \text{Var}(y) - \lambda \end{pmatrix} = 0$$
                            </div>
                        </div>
                    </div>

                    <div class="concept-box">
                        <h4>What is the Determinant?</h4>
                        <p>For a 2√ó2 matrix $\begin{pmatrix} a & b \\ c & d \end{pmatrix}$, the determinant is $ad - bc$. Geometrically, the determinant measures how much a transformation "scales area":</p>
                        <p>‚Ä¢ <strong>Det = 0:</strong> The matrix squashes space onto a line ‚Äî it loses a dimension entirely</p>
                        <p>‚Ä¢ <strong>Det ‚â† 0:</strong> The matrix is invertible ‚Äî no dimension is completely lost</p>
                        <p style="margin-top: 0.5rem;"><strong>Why we need it:</strong> To find eigenvalues, we solve det(Œ£ - ŒªI) = 0. We're looking for values of Œª that make this matrix <em>singular</em> (det = 0), meaning it collapses some direction. Those Œª values are the eigenvalues.</p>
                        <p style="margin-top: 0.5rem;"><strong>Why not just drop the x or y axis?</strong> We could simply ignore one coordinate, but that would be wasteful. If your data spreads diagonally (i.e., if there is correlation), dropping x loses half the information and dropping y loses the other half. Can we do better and lose less information? Yes, by first <em>rotating</em> our coordinate system to align with the directions where the data varies most, then dropping the direction with the least variance. The eigenvectors tell us exactly how to rotate: they point along the data's principal axes. This way, we keep the direction with maximum variance (PC1) and only discard the direction (PC2)where the data barely varies anyway.</p>
                    </div>

                    <div class="concept-box">
                        <h4>What det(Œ£) Tells Us About Our Data</h4>
                        <p>Since <strong>det(Œ£) = Œª‚ÇÅ √ó Œª‚ÇÇ</strong> (product of eigenvalues):</p>
                        <p>‚Ä¢ <strong>det(Œ£) near 0:</strong> One eigenvalue must be small ‚Üí data is nearly 1D (highly correlated) ‚Üí PCA projection loses little information</p>
                        <p>‚Ä¢ <strong>det(Œ£) larger:</strong> Both eigenvalues are substantial ‚Üí data genuinely spreads in 2D ‚Üí PCA projection loses more information</p>
                        <p style="margin-top: 0.5rem;">The key comparison is: <strong>how small is det relative to the total variance?</strong> A ratio Œª‚ÇÅ/Œª‚ÇÇ tells us the elongation of the data ellipse.</p>
                    </div>

                    <div class="math-section">
                        <h4>Step 3b: Expand to Get a Quadratic Equation</h4>
                        <div class="math-content">
                            <p style="font-size: 0.85rem; margin-bottom: 0.5rem;">Applying the determinant formula $ad - bc$ to our matrix:</p>
                            <div class="math-formula">
                                $$(\text{Var}(x) - \lambda)(\text{Var}(y) - \lambda) - \text{Cov}(x,y)^2 = 0$$
                            </div>
                            <p style="font-size: 0.85rem;">Expanding $(a-\lambda)(b-\lambda) = ab - a\lambda - b\lambda + \lambda^2$ gives us a <strong>quadratic equation in Œª</strong>:</p>
                            <div class="math-formula">
                                $$\lambda^2 - \underbrace{(\text{Var}(x) + \text{Var}(y))}_{\text{trace}} \lambda + \underbrace{(\text{Var}(x) \cdot \text{Var}(y) - \text{Cov}(x,y)^2)}_{\text{determinant}} = 0$$
                            </div>
                            <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">This quadratic has two solutions ‚Äî those are our two eigenvalues Œª‚ÇÅ and Œª‚ÇÇ.</p>
                            <div class="computed-value" id="charEqComputed" style="font-size: 0.8rem;">
                                Substituting your values: ...
                            </div>
                        </div>
                    </div>
                    
                    <div class="concept-box">
                        <h4>What is the Trace?</h4>
                        <p><strong>Trace = Var(x) + Var(y)</strong> ‚Äî the sum of the diagonal elements.</p>
                        <p>The trace represents the <em>total variance</em> in your data. Notice it appears as the coefficient of Œª in the quadratic equation above. Importantly, <strong>trace = Œª‚ÇÅ + Œª‚ÇÇ</strong> ‚Äî the eigenvalues partition the total variance between the principal components.</p>
                    </div>

                    <div class="math-section">
                        <h4>Step 3c: Solve Using the Quadratic Formula</h4>
                        <div class="math-content">
                            <p style="font-size: 0.85rem;">Our equation $\lambda^2 - \text{trace} \cdot \lambda + \text{det} = 0$ is a standard quadratic $ax^2 + bx + c = 0$.</p>
                            <div class="computed-value" id="traceDetComputed">
                                trace(Œ£) = ?, &nbsp; det(Œ£) = ?
                            </div>
                            <div class="computed-value" id="traceDetInterpret" style="font-style: italic; background: #fffbe6; border-color: #ffe58f;">
                                What this means: ...
                            </div>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem;">Using the quadratic formula $x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$:</p>
                            <div class="math-formula">
                                $$\lambda = \frac{\text{trace} \pm \sqrt{\text{trace}^2 - 4 \cdot \text{det}}}{2}$$
                            </div>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem;">
                                <div class="computed-value highlight-result" id="lambda1Computed" style="flex: 1;">
                                    <span class="highlight-pc1">Œª‚ÇÅ = ?</span> (PC1 - larger)
                                </div>
                                <div class="computed-value highlight-result" id="lambda2Computed" style="flex: 1;">
                                    <span class="highlight-pc2">Œª‚ÇÇ = ?</span> (PC2 - smaller)
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="math-section">
                        <h4>Step 3d: Find Eigenvectors</h4>
                        <div class="math-content">
                            <p style="font-size: 0.85rem; margin-bottom: 0.5rem;">For each Œª, solve <strong>(Œ£ - ŒªI)v = 0</strong>:</p>
                            <div class="math-formula">
                                $$\begin{pmatrix} \text{Var}(x) - \lambda & \text{Cov}(x,y) \\ \text{Cov}(x,y) & \text{Var}(y) - \lambda \end{pmatrix} \begin{pmatrix} v_x \\ v_y \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}$$
                            </div>
                            <p style="font-size: 0.85rem;">From the first row: $(\text{Var}(x) - \lambda)v_x + \text{Cov}(x,y) \cdot v_y = 0$</p>
                            <p style="font-size: 0.85rem; margin-bottom: 0.5rem;">Solving and normalizing gives:</p>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                                <div class="computed-value highlight-result" id="v1Computed" style="flex: 1;">
                                    <span class="highlight-pc1">v‚ÇÅ = (?, ?)</span>
                                </div>
                                <div class="computed-value highlight-result" id="v2Computed" style="flex: 1;">
                                    <span class="highlight-pc2">v‚ÇÇ = (?, ?)</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="insight-box">
                        <h4>The Variance Ellipse</h4>
                        <ul>
                            <li>The ellipse axes align with the eigenvectors (PC1 and PC2)</li>
                            <li>Axis lengths are proportional to ‚àöŒª (standard deviation along each direction)</li>
                            <li><strong>Elongated ellipse:</strong> PC1 captures most variance</li>
                            <li><strong>Nearly circular:</strong> Both PCs are equally important</li>
                        </ul>
                    </div>

                    <div class="math-section">
                        <h4>Variance Explained</h4>
                        <div class="math-content">
                            <div class="math-formula">
                                $$\text{Variance explained by PC}_i = \frac{\lambda_i}{\lambda_1 + \lambda_2} \times 100\%$$
                            </div>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem;">
                                <div class="computed-value highlight-result" id="var1Explained" style="flex: 1;">
                                    <span class="highlight-pc1">PC1: ?%</span>
                                </div>
                                <div class="computed-value highlight-result" id="var2Explained" style="flex: 1;">
                                    <span class="highlight-pc2">PC2: ?%</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem;">
                                <div class="computed-value" id="axis1Computed" style="flex: 1;">
                                    <span class="highlight-pc1">‚àöŒª‚ÇÅ = ?</span> (PC1 std dev)
                                </div>
                                <div class="computed-value" id="axis2Computed" style="flex: 1;">
                                    <span class="highlight-pc2">‚àöŒª‚ÇÇ = ?</span> (PC2 std dev)
                                </div>
                            </div>
                            <div class="computed-value" id="angleComputed">
                                Rotation angle Œ∏ = ?¬∞
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="continue-container">
                <button class="btn success large" id="btnStartStep4">
                    Continue to Step 4: Project Data ‚Üí
                </button>
            </div>
        </section>

        <!-- STEP 4: Project Data (was Step 5) -->
        <section class="step-section hidden" id="step4Section">
            <h2><span class="step-badge">Step 4</span> Project onto Principal Component</h2>
            <div class="step-content">
                <div class="step-canvas">
                    <canvas id="canvas4" width="320" height="320"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot" style="background: #3498db;"></div> Original (2D)</div>
                        <div class="legend-item"><div class="legend-dot" style="background: #27ae60;"></div> Projected (1D)</div>
                        <div class="legend-item"><div class="legend-line" style="background: rgba(231,76,60,0.4);"></div> PC1 Line</div>
                    </div>
                    <div class="canvas-controls">
                        <button class="btn toggle" id="btnToggleStep4">Show Projection</button>
                    </div>
                </div>
                <div class="step-explanation">
                    <div class="explanation-box">
                        <h4>Dimensionality Reduction</h4>
                        <p>By projecting each point onto PC1, we reduce 2D data to 1D while keeping the direction of maximum variance. The distance from each original point to its projection represents the information "lost" (variance along PC2).</p>
                    </div>
                    <div class="insight-box">
                        <h4>The Trade-off</h4>
                        <ul>
                            <li><strong>High PC1 variance:</strong> Little information lost in projection</li>
                            <li><strong>Low PC2 variance:</strong> The "lost" dimension didn't carry much signal anyway</li>
                            <li><strong>This is compression:</strong> We go from 2 numbers per point to 1 number.</li>
                        </ul>
                    </div>
                    <div class="math-section">
                        <h4>Projection Formula</h4>
                        <div class="math-content">
                            <p style="font-size: 0.85rem;">To project point <strong>x</strong> onto PC1 (eigenvector <strong>v‚ÇÅ</strong>):</p>
                            <div class="math-formula">
                                $$\mathbf{x}_{\text{proj}} = \underbrace{(\mathbf{x} \cdot \mathbf{v}_1)}_{\text{scalar score}} \cdot \underbrace{\mathbf{v}_1}_{\text{direction}}$$
                            </div>
                        </div>
                    </div>
                    <div class="insight-box">
                        <h4>Why Multiply by v‚ÇÅ Again?</h4>
                        <p>The projection happens in <strong>two steps</strong> with different purposes:</p>
                        <ul>
                            <li><strong>Step 1: Dot product (x ¬∑ v‚ÇÅ)</strong> ‚Üí gives a <em>scalar</em> (single number). This is the "score" or coordinate in the new 1D space. If you only want dimensionality reduction, you can stop here.</li>
                            <li><strong>Step 2: Multiply by v‚ÇÅ</strong> ‚Üí converts the scalar back to a <em>2D point</em>. This tells us WHERE on the PC1 line the projection lands (for visualization or reconstruction).</li>
                        </ul>
                        <p style="margin-top: 0.5rem;"><strong>Example:</strong> If score = 2.5 and v‚ÇÅ = (0.8, 0.6), then:</p>
                        <p style="margin-left: 1rem;">‚Ä¢ Score alone: just "2.5" (1D representation)</p>
                        <p style="margin-left: 1rem;">‚Ä¢ Projected point: 2.5 √ó (0.8, 0.6) = (2.0, 1.5) (location in 2D)</p>
                    </div>
                    <div class="math-section">
                        <h4>Information Retained vs Lost</h4>
                        <div class="math-content">
                            <div class="computed-value highlight-result" id="infoRetained">
                                <span class="highlight-pc1">Information retained (PC1): ?%</span>
                            </div>
                            <div class="computed-value" id="infoLost">
                                <span class="highlight-pc2">Information lost (PC2): ?%</span>
                            </div>
                            <p style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                                This is the core tradeoff of PCA: we sacrifice some variance (information) for a lower-dimensional representation.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="continue-container">
                <button class="btn primary large" id="btnRestart">
                    ‚Ü∫ Start Over with New Data
                </button>
            </div>
        </section>

        <footer>
            <a href="../index.html">‚Üê Back to Home Page</a>
        </footer>
    </div>

    <script>
        // =========================================
        // 2D PCA STEP-BY-STEP VISUALIZATION
        // =========================================

        (function() {
            'use strict';

            // -----------------------------------------
            // CONFIGURATION & STATE
            // -----------------------------------------
            const CANVAS_SIZE = 320;
            const LOGICAL_MIN = -4;
            const LOGICAL_MAX = 4;
            const LOGICAL_RANGE = LOGICAL_MAX - LOGICAL_MIN;

            // Get all canvases
            const canvases = {
                c0: document.getElementById('canvas0'),
                c1: document.getElementById('canvas1'),
                c2: document.getElementById('canvas2'),
                c3: document.getElementById('canvas3'),
                c4: document.getElementById('canvas4')
            };
            const contexts = {};
            for (let key in canvases) {
                contexts[key] = canvases[key].getContext('2d');
            }

            // State
            let originalPoints = [];
            let centeredPoints = [];
            let mean = [0, 0];
            let covMatrix = [[1, 0], [0, 1]];
            let eigenvalues = [1, 1];
            let eigenvectors = [[1, 0], [0, 1]];

            // Toggle states for each step
            let step1Shown = false;
            let step2Shown = false;
            let step3PC1Shown = false;
            let step3PC2Shown = false;
            let step3EllipseShown = false;
            let step4Shown = false;

            // -----------------------------------------
            // COORDINATE TRANSFORMATIONS
            // -----------------------------------------
            function toCanvas(x, y) {
                const cx = ((x - LOGICAL_MIN) / LOGICAL_RANGE) * CANVAS_SIZE;
                const cy = CANVAS_SIZE - ((y - LOGICAL_MIN) / LOGICAL_RANGE) * CANVAS_SIZE;
                return [cx, cy];
            }

            function toLogical(canvasX, canvasY) {
                const x = (canvasX / CANVAS_SIZE) * LOGICAL_RANGE + LOGICAL_MIN;
                const y = ((CANVAS_SIZE - canvasY) / CANVAS_SIZE) * LOGICAL_RANGE + LOGICAL_MIN;
                return [x, y];
            }

            function scaleLength(len) {
                return (len / LOGICAL_RANGE) * CANVAS_SIZE;
            }

            // -----------------------------------------
            // DRAWING UTILITIES
            // -----------------------------------------
            function drawGrid(ctx) {
                ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

                // Grid lines
                ctx.strokeStyle = '#e8e8e8';
                ctx.lineWidth = 1;
                for (let i = LOGICAL_MIN; i <= LOGICAL_MAX; i++) {
                    const [vx] = toCanvas(i, 0);
                    ctx.beginPath();
                    ctx.moveTo(vx, 0);
                    ctx.lineTo(vx, CANVAS_SIZE);
                    ctx.stroke();

                    const [, hy] = toCanvas(0, i);
                    ctx.beginPath();
                    ctx.moveTo(0, hy);
                    ctx.lineTo(CANVAS_SIZE, hy);
                    ctx.stroke();
                }

                // Axes
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 1.5;
                const [, yAxis] = toCanvas(0, 0);
                ctx.beginPath();
                ctx.moveTo(0, yAxis);
                ctx.lineTo(CANVAS_SIZE, yAxis);
                ctx.stroke();

                const [xAxis] = toCanvas(0, 0);
                ctx.beginPath();
                ctx.moveTo(xAxis, 0);
                ctx.lineTo(xAxis, CANVAS_SIZE);
                ctx.stroke();

                // Labels
                ctx.fillStyle = '#888';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                for (let i = LOGICAL_MIN; i <= LOGICAL_MAX; i++) {
                    if (i === 0) continue;
                    const [x, y] = toCanvas(i, 0);
                    ctx.fillText(i.toString(), x, yAxis + 12);
                }
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (let i = LOGICAL_MIN; i <= LOGICAL_MAX; i++) {
                    if (i === 0) continue;
                    const [x, y] = toCanvas(0, i);
                    ctx.fillText(i.toString(), xAxis - 5, y);
                }
            }

            function drawPoint(ctx, x, y, color = '#333', radius = 5, hollow = false) {
                const [cx, cy] = toCanvas(x, y);
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                if (hollow) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }

            function drawVector(ctx, x1, y1, x2, y2, color, lineWidth = 2.5) {
                const [cx1, cy1] = toCanvas(x1, y1);
                const [cx2, cy2] = toCanvas(x2, y2);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(cx1, cy1);
                ctx.lineTo(cx2, cy2);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(cy2 - cy1, cx2 - cx1);
                const headLen = 10;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(cx2, cy2);
                ctx.lineTo(cx2 - headLen * Math.cos(angle - Math.PI / 6), cy2 - headLen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(cx2 - headLen * Math.cos(angle + Math.PI / 6), cy2 - headLen * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
            }

            function drawEllipse(ctx, cx, cy, a, b, rotation, color) {
                const [canvasCx, canvasCy] = toCanvas(cx, cy);
                const canvasA = scaleLength(a);
                const canvasB = scaleLength(b);

                ctx.save();
                ctx.translate(canvasCx, canvasCy);
                ctx.rotate(-rotation);

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.ellipse(0, 0, canvasA, canvasB, 0, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = color.replace(')', ', 0.1)').replace('rgb', 'rgba');
                ctx.beginPath();
                ctx.ellipse(0, 0, canvasA, canvasB, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.setLineDash([]);
                ctx.restore();
            }

            function drawLine(ctx, x1, y1, x2, y2, color, lineWidth = 2, dashed = false) {
                const [cx1, cy1] = toCanvas(x1, y1);
                const [cx2, cy2] = toCanvas(x2, y2);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                if (dashed) ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(cx1, cy1);
                ctx.lineTo(cx2, cy2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // -----------------------------------------
            // MATH FUNCTIONS
            // -----------------------------------------
            function computeMean(points) {
                if (points.length === 0) return [0, 0];
                let sx = 0, sy = 0;
                points.forEach(([x, y]) => { sx += x; sy += y; });
                return [sx / points.length, sy / points.length];
            }

            function centerPoints(points, m) {
                return points.map(([x, y]) => [x - m[0], y - m[1]]);
            }

            function computeCovariance(points) {
                const n = points.length;
                if (n < 2) return [[1, 0], [0, 1]];

                let sxx = 0, syy = 0, sxy = 0;
                points.forEach(([x, y]) => {
                    sxx += x * x;
                    syy += y * y;
                    sxy += x * y;
                });

                const factor = 1 / (n - 1);
                return [
                    [sxx * factor, sxy * factor],
                    [sxy * factor, syy * factor]
                ];
            }

            function computeEigen(cov) {
                const a = cov[0][0], b = cov[0][1], c = cov[1][1];
                const trace = a + c;
                const det = a * c - b * b;
                const disc = Math.sqrt(Math.max(0, trace * trace / 4 - det));

                let l1 = trace / 2 + disc;
                let l2 = trace / 2 - disc;

                if (l1 < l2) [l1, l2] = [l2, l1];

                // Eigenvectors
                let v1, v2;
                if (Math.abs(b) > 1e-10) {
                    v1 = [l1 - c, b];
                    v2 = [l2 - c, b];
                } else if (a >= c) {
                    v1 = [1, 0];
                    v2 = [0, 1];
                } else {
                    v1 = [0, 1];
                    v2 = [1, 0];
                }

                // Normalize
                const norm1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
                const norm2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
                v1 = [v1[0] / norm1, v1[1] / norm1];
                v2 = [v2[0] / norm2, v2[1] / norm2];

                return {
                    eigenvalues: [Math.max(0, l1), Math.max(0, l2)],
                    eigenvectors: [v1, v2],
                    trace: trace,
                    det: det
                };
            }

            // -----------------------------------------
            // DATA GENERATION
            // -----------------------------------------
            function generateRandom(n = 20) {
                const pts = [];
                // Random offset to make centering visually meaningful
                const offsetX = (Math.random() - 0.5) * 2 + (Math.random() > 0.5 ? 0.8 : -0.8);
                const offsetY = (Math.random() - 0.5) * 2 + (Math.random() > 0.5 ? 0.8 : -0.8);
                for (let i = 0; i < n; i++) {
                    pts.push([(Math.random() - 0.5) * 5 + offsetX, (Math.random() - 0.5) * 5 + offsetY]);
                }
                return pts;
            }

            function generateCorrelated(n = 22) {
                const pts = [];
                // Random angle between 15¬∞ and 75¬∞ (positive slope)
                const angle = (Math.random() * 60 + 15) * Math.PI / 180;
                const cosA = Math.cos(angle);
                const sinA = Math.sin(angle);
                // Random spread perpendicular to the line (0.3 to 0.8)
                const spread = Math.random() * 0.5 + 0.3;
                // Random offset to make centering visually meaningful
                const offsetX = (Math.random() - 0.5) * 1.5 + (Math.random() > 0.5 ? 0.8 : -0.8);
                const offsetY = (Math.random() - 0.5) * 1.5 + (Math.random() > 0.5 ? 0.8 : -0.8);
                for (let i = 0; i < n; i++) {
                    const t = (Math.random() - 0.5) * 5; // Along the line
                    const noise = (Math.random() - 0.5) * 2 * spread; // Perpendicular noise
                    pts.push([t * cosA - noise * sinA + offsetX, t * sinA + noise * cosA + offsetY]);
                }
                return pts;
            }

            function generateNegCorrelated(n = 22) {
                const pts = [];
                // Random angle between 105¬∞ and 165¬∞ (negative slope)
                const angle = (Math.random() * 60 + 105) * Math.PI / 180;
                const cosA = Math.cos(angle);
                const sinA = Math.sin(angle);
                // Random spread perpendicular to the line (0.3 to 0.8)
                const spread = Math.random() * 0.5 + 0.3;
                // Random offset to make centering visually meaningful
                const offsetX = (Math.random() - 0.5) * 1.5 + (Math.random() > 0.5 ? 0.8 : -0.8);
                const offsetY = (Math.random() - 0.5) * 1.5 + (Math.random() > 0.5 ? 0.8 : -0.8);
                for (let i = 0; i < n; i++) {
                    const t = (Math.random() - 0.5) * 5; // Along the line
                    const noise = (Math.random() - 0.5) * 2 * spread; // Perpendicular noise
                    pts.push([t * cosA - noise * sinA + offsetX, t * sinA + noise * cosA + offsetY]);
                }
                return pts;
            }

            function generateCircular(n = 22) {
                const pts = [];
                // Random offset to make centering visually meaningful
                const offsetX = (Math.random() - 0.5) * 1.5 + (Math.random() > 0.5 ? 0.8 : -0.8);
                const offsetY = (Math.random() - 0.5) * 1.5 + (Math.random() > 0.5 ? 0.8 : -0.8);
                for (let i = 0; i < n; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 1.8 + 0.3;
                    pts.push([Math.cos(angle) * r + offsetX, Math.sin(angle) * r + offsetY]);
                }
                return pts;
            }

            // -----------------------------------------
            // RENDER FUNCTIONS
            // -----------------------------------------
            function renderCanvas0() {
                const ctx = contexts.c0;
                drawGrid(ctx);
                originalPoints.forEach(([x, y]) => drawPoint(ctx, x, y, '#2c3e50', 5));
            }

            function renderCanvas1() {
                const ctx = contexts.c1;
                drawGrid(ctx);
                
                if (step1Shown) {
                    // Show original points as ghosts
                    originalPoints.forEach(([x, y]) => drawPoint(ctx, x, y, '#ccc', 4));
                    // Show centered points
                    centeredPoints.forEach(([x, y]) => drawPoint(ctx, x, y, '#3498db', 5));
                    // Show mean at origin (where it moved to after centering)
                    drawPoint(ctx, 0, 0, '#e74c3c', 6, true);
                } else {
                    // Show original points with mean marker at original position
                    originalPoints.forEach(([x, y]) => drawPoint(ctx, x, y, '#3498db', 5));
                    if (originalPoints.length >= 3) {
                        drawPoint(ctx, mean[0], mean[1], '#e74c3c', 6, true);
                        // Arrow from mean to origin showing where it will move
                        drawLine(ctx, mean[0], mean[1], 0, 0, '#e74c3c', 1.5, true);
                    }
                }
            }

            function renderCanvas2() {
                const ctx = contexts.c2;
                drawGrid(ctx);
                
                centeredPoints.forEach(([x, y]) => drawPoint(ctx, x, y, '#3498db', 5));
                
                if (step2Shown) {
                    const varX = covMatrix[0][0];
                    const varY = covMatrix[1][1];
                    const covXY = covMatrix[0][1];
                    
                    // Draw variance visualization - lines from each point to axes
                    centeredPoints.forEach(([x, y]) => {
                        // Horizontal line (contributes to Var(x))
                        drawLine(ctx, 0, y, x, y, 'rgba(231, 76, 60, 0.3)', 1);
                        // Vertical line (contributes to Var(y))
                        drawLine(ctx, x, 0, x, y, 'rgba(155, 89, 182, 0.3)', 1);
                    });
                    
                    // Draw spread indicators
                    const maxX = Math.max(...centeredPoints.map(p => Math.abs(p[0])));
                    const maxY = Math.max(...centeredPoints.map(p => Math.abs(p[1])));
                    
                    // Horizontal spread bar (Var(x)) with value
                    drawLine(ctx, -maxX, -3.5, maxX, -3.5, '#e74c3c', 3);
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.textAlign = 'center';
                    const [, barY] = toCanvas(0, -3.5);
                    ctx.fillText(`Var(x) = ${varX.toFixed(2)}`, CANVAS_SIZE / 2, barY - 8);
                    
                    // Vertical spread bar (Var(y)) with value
                    drawLine(ctx, -3.5, -maxY, -3.5, maxY, '#9b59b6', 3);
                    ctx.save();
                    ctx.fillStyle = '#9b59b6';
                    const [barX] = toCanvas(-3.5, 0);
                    ctx.translate(barX - 8, CANVAS_SIZE / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText(`Var(y) = ${varY.toFixed(2)}`, 0, 0);
                    ctx.restore();
                    
                    // Draw covariance slope line (shorter, within data range)
                    if (Math.abs(covXY) > 0.01 && varX > 0.01) {
                        // Slope = Cov(x,y) / Var(x) for regression line y = slope * x
                        const slope = covXY / varX;
                        // Keep line within reasonable bounds
                        const xRange = Math.min(2.5, maxX * 1.2);
                        drawLine(ctx, -xRange, -xRange * slope, xRange, xRange * slope, '#f39c12', 3);
                        
                        // Label positioned safely in a corner
                        ctx.fillStyle = '#f39c12';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'right';
                        const [lx, ly] = toCanvas(3.3, 3.5);
                        const slopeSign = covXY > 0 ? '+' : '';
                        ctx.fillText(`Cov = ${slopeSign}${covXY.toFixed(2)}`, lx, ly);
                    } else {
                        // Near-zero covariance - draw horizontal dashed line at 0
                        drawLine(ctx, -2.5, 0, 2.5, 0, '#f39c12', 2, true);
                        ctx.fillStyle = '#f39c12';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'right';
                        const [lx, ly] = toCanvas(3.3, 3.5);
                        ctx.fillText(`Cov ‚âà 0`, lx, ly);
                    }
                }
            }

            function renderCanvas3() {
                const ctx = contexts.c3;
                drawGrid(ctx);

                // Draw ellipse first (behind everything)
                if (step3EllipseShown) {
                    const a = Math.sqrt(eigenvalues[0]) * 2;
                    const b = Math.sqrt(eigenvalues[1]) * 2;
                    const rotation = Math.atan2(eigenvectors[0][1], eigenvectors[0][0]);
                    drawEllipse(ctx, 0, 0, a, b, rotation, 'rgb(155, 89, 182)');
                }

                // Data points
                centeredPoints.forEach(([x, y]) => drawPoint(ctx, x, y, '#3498db', 5));

                const scale1 = Math.sqrt(eigenvalues[0]) * 1.8;
                const scale2 = Math.sqrt(eigenvalues[1]) * 1.8;
                const v1 = eigenvectors[0], v2 = eigenvectors[1];

                if (step3PC1Shown) {
                    // PC1 (both directions)
                    drawLine(ctx, -v1[0] * scale1, -v1[1] * scale1, v1[0] * scale1, v1[1] * scale1, '#e74c3c', 2.5);
                    drawVector(ctx, 0, 0, v1[0] * scale1, v1[1] * scale1, '#e74c3c', 2.5);
                    
                    // Label
                    const [lx1, ly1] = toCanvas(v1[0] * scale1 * 1.15, v1[1] * scale1 * 1.15);
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillStyle = '#e74c3c';
                    ctx.textAlign = 'center';
                    ctx.fillText('PC1', lx1, ly1);
                }
                
                if (step3PC2Shown) {
                    // PC2 (both directions)
                    drawLine(ctx, -v2[0] * scale2, -v2[1] * scale2, v2[0] * scale2, v2[1] * scale2, '#9b59b6', 2.5);
                    drawVector(ctx, 0, 0, v2[0] * scale2, v2[1] * scale2, '#9b59b6', 2.5);
                    
                    // Label
                    const [lx2, ly2] = toCanvas(v2[0] * scale2 * 1.15, v2[1] * scale2 * 1.15);
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillStyle = '#9b59b6';
                    ctx.textAlign = 'center';
                    ctx.fillText('PC2', lx2, ly2);
                }
            }

            function renderCanvas4() {
                const ctx = contexts.c4;
                drawGrid(ctx);

                const v1 = eigenvectors[0];
                
                // Extended PC1 line
                drawLine(ctx, -v1[0] * 5, -v1[1] * 5, v1[0] * 5, v1[1] * 5, 'rgba(231, 76, 60, 0.35)', 4);

                // Draw points based on projection state
                centeredPoints.forEach(([x, y]) => {
                    const dot = x * v1[0] + y * v1[1];
                    const px = dot * v1[0];
                    const py = dot * v1[1];

                    if (step4Shown) {
                        // Only show projected points on the line (original points disappear)
                        drawPoint(ctx, px, py, '#27ae60', 5);
                    } else {
                        // Show original 2D points
                        drawPoint(ctx, x, y, '#3498db', 5);
                    }
                });
            }

            // -----------------------------------------
            // UPDATE UI
            // -----------------------------------------
            function updateDataTable() {
                const tbody = document.getElementById('dataTableBody');
                if (originalPoints.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; color: #999;">No data yet</td></tr>';
                    return;
                }
                let html = '';
                originalPoints.slice(0, 15).forEach((p, i) => {
                    html += `<tr><td>${i + 1}</td><td>${p[0].toFixed(2)}</td><td>${p[1].toFixed(2)}</td></tr>`;
                });
                if (originalPoints.length > 15) {
                    html += `<tr><td colspan="3" style="text-align: center; color: #999;">... and ${originalPoints.length - 15} more</td></tr>`;
                }
                tbody.innerHTML = html;
            }

            function updatePointCount() {
                document.getElementById('pointCount').textContent = originalPoints.length;
                document.getElementById('btnStartStep1').disabled = originalPoints.length < 3;
            }

            function showStep(stepNum) {
                for (let i = 1; i <= 4; i++) {
                    const section = document.getElementById(`step${i}Section`);
                    if (i <= stepNum) {
                        section.classList.remove('hidden');
                    } else {
                        section.classList.add('hidden');
                    }
                }
                
                const targetSection = document.getElementById(`step${stepNum}Section`);
                if (targetSection) {
                    targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }

            function updateButtonState(btnId, isActive) {
                const btn = document.getElementById(btnId);
                if (isActive) {
                    btn.classList.add('active');
                    btn.textContent = btn.textContent.replace('Show', 'Hide');
                } else {
                    btn.classList.remove('active');
                    btn.textContent = btn.textContent.replace('Hide', 'Show');
                }
            }

            function updateMathDisplay() {
                const varX = covMatrix[0][0];
                const varY = covMatrix[1][1];
                const covXY = covMatrix[0][1];
                
                // Step 1: Mean
                document.getElementById('meanComputed').innerHTML = 
                    `Computed mean: <strong>Œº = (${mean[0].toFixed(3)}, ${mean[1].toFixed(3)})</strong>`;

                // Step 2: Covariance
                document.getElementById('covMatrixComputed').innerHTML = 
                    `<strong>Œ£ = </strong>[ [${varX.toFixed(3)}, ${covXY.toFixed(3)}], [${covXY.toFixed(3)}, ${varY.toFixed(3)}] ]`;
                document.getElementById('varXComputed').innerHTML = `Var(x) = <strong>${varX.toFixed(3)}</strong>`;
                document.getElementById('varYComputed').innerHTML = `Var(y) = <strong>${varY.toFixed(3)}</strong>`;
                document.getElementById('covXYComputed').innerHTML = `Cov(x,y) = <strong>${covXY.toFixed(3)}</strong>`;
                
                // Covariance interpretation
                let covInterpret = '';
                if (covXY > 0.3) {
                    covInterpret = `Positive correlation: when x increases, y tends to increase (upward trend)`;
                } else if (covXY < -0.3) {
                    covInterpret = `Negative correlation: when x increases, y tends to decrease (downward trend)`;
                } else {
                    covInterpret = `Little correlation: x and y vary mostly independently`;
                }
                if (varX > varY * 1.5) {
                    covInterpret += `. Data is more spread horizontally.`;
                } else if (varY > varX * 1.5) {
                    covInterpret += `. Data is more spread vertically.`;
                }
                document.getElementById('covInterpretation').innerHTML = covInterpret;
                
                // Update the interactive explorer hint with computed values
                document.getElementById('covExplorerDataHint').innerHTML = 
                    `<strong>Your data:</strong> Var(x)=${varX.toFixed(2)}, Var(y)=${varY.toFixed(2)}, Cov=${covXY.toFixed(2)} ‚Äî try these values to see the transformation that produces your data's shape!`;

                // Step 3: Eigenvalues
                const trace = varX + varY;
                const det = varX * varY - covXY * covXY;
                document.getElementById('charEqComputed').innerHTML = 
                    `(${varX.toFixed(2)} - Œª)(${varY.toFixed(2)} - Œª) - (${covXY.toFixed(2)})¬≤ = 0`;
                document.getElementById('traceDetComputed').innerHTML = 
                    `<strong>trace(Œ£) = ${trace.toFixed(3)}</strong> (total variance), &nbsp; <strong>det(Œ£) = ${det.toFixed(3)}</strong>`;
                
                const ratio = det > 0 ? Math.sqrt(eigenvalues[0] / eigenvalues[1]) : 1;
                let traceDetInterpret = `Total variance = ${trace.toFixed(2)}. `;
                if (ratio > 3) {
                    traceDetInterpret += `Eigenvalue ratio ${ratio.toFixed(1)}:1 ‚Üí highly correlated data (elongated ellipse). PCA compression will lose little info.`;
                } else if (ratio > 1.5) {
                    traceDetInterpret += `Eigenvalue ratio ${ratio.toFixed(1)}:1 ‚Üí moderate correlation (somewhat elongated ellipse).`;
                } else {
                    traceDetInterpret += `Eigenvalue ratio ${ratio.toFixed(1)}:1 ‚Üí data spreads in multiple directions (rounder ellipse). Both PCs carry information.`;
                }
                document.getElementById('traceDetInterpret').innerHTML = traceDetInterpret;
                
                document.getElementById('lambda1Computed').innerHTML = 
                    `<span class="highlight-pc1">Œª‚ÇÅ = ${eigenvalues[0].toFixed(4)}</span> (PC1 - larger)`;
                document.getElementById('lambda2Computed').innerHTML = 
                    `<span class="highlight-pc2">Œª‚ÇÇ = ${eigenvalues[1].toFixed(4)}</span> (PC2 - smaller)`;
                document.getElementById('v1Computed').innerHTML = 
                    `<span class="highlight-pc1">v‚ÇÅ = (${eigenvectors[0][0].toFixed(3)}, ${eigenvectors[0][1].toFixed(3)})</span>`;
                document.getElementById('v2Computed').innerHTML = 
                    `<span class="highlight-pc2">v‚ÇÇ = (${eigenvectors[1][0].toFixed(3)}, ${eigenvectors[1][1].toFixed(3)})</span>`;

                // Ellipse/variance explained
                const std1 = Math.sqrt(eigenvalues[0]);
                const std2 = Math.sqrt(eigenvalues[1]);
                const angle = Math.atan2(eigenvectors[0][1], eigenvectors[0][0]) * 180 / Math.PI;
                document.getElementById('axis1Computed').innerHTML = 
                    `<span class="highlight-pc1">‚àöŒª‚ÇÅ = ${std1.toFixed(3)}</span> (PC1 std dev)`;
                document.getElementById('axis2Computed').innerHTML = 
                    `<span class="highlight-pc2">‚àöŒª‚ÇÇ = ${std2.toFixed(3)}</span> (PC2 std dev)`;
                document.getElementById('angleComputed').innerHTML = 
                    `Rotation angle Œ∏ = <strong>${angle.toFixed(1)}¬∞</strong>`;

                const totalVar = eigenvalues[0] + eigenvalues[1];
                const pct1 = totalVar > 0 ? (eigenvalues[0] / totalVar * 100) : 50;
                const pct2 = totalVar > 0 ? (eigenvalues[1] / totalVar * 100) : 50;
                document.getElementById('var1Explained').innerHTML = 
                    `<span class="highlight-pc1">PC1: ${pct1.toFixed(1)}%</span>`;
                document.getElementById('var2Explained').innerHTML = 
                    `<span class="highlight-pc2">PC2: ${pct2.toFixed(1)}%</span>`;

                // Step 4: Projection info
                document.getElementById('infoRetained').innerHTML = 
                    `<span class="highlight-pc1">Information retained (PC1): ${pct1.toFixed(1)}%</span>`;
                document.getElementById('infoLost').innerHTML = 
                    `<span class="highlight-pc2">Information lost (PC2): ${pct2.toFixed(1)}%</span>`;
            }

            function computeAllValues() {
                mean = computeMean(originalPoints);
                centeredPoints = centerPoints(originalPoints, mean);
                covMatrix = computeCovariance(centeredPoints);
                const result = computeEigen(covMatrix);
                eigenvalues = result.eigenvalues;
                eigenvectors = result.eigenvectors;
                updateMathDisplay();
            }

            function resetAll() {
                originalPoints = [];
                centeredPoints = [];
                mean = [0, 0];
                covMatrix = [[1, 0], [0, 1]];
                eigenvalues = [1, 1];
                eigenvectors = [[1, 0], [0, 1]];
                
                // Reset toggle states
                step1Shown = false;
                step2Shown = false;
                step3PC1Shown = false;
                step3PC2Shown = false;
                step3EllipseShown = false;
                step4Shown = false;

                updatePointCount();
                updateDataTable();
                
                // Reset button states
                updateButtonState('btnToggleStep1', false);
                updateButtonState('btnToggleStep2', false);
                updateButtonState('btnToggleStep3PC1', false);
                updateButtonState('btnToggleStep3PC2', false);
                updateButtonState('btnToggleStep3Ellipse', false);
                updateButtonState('btnToggleStep4', false);

                // Hide all steps except step 0
                for (let i = 1; i <= 4; i++) {
                    document.getElementById(`step${i}Section`).classList.add('hidden');
                }

                // Clear all canvases
                for (let key in contexts) {
                    drawGrid(contexts[key]);
                }

                document.getElementById('step0Section').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            // -----------------------------------------
            // EVENT HANDLERS
            // -----------------------------------------
            canvases.c0.addEventListener('click', function(e) {
                const rect = canvases.c0.getBoundingClientRect();
                const scaleX = CANVAS_SIZE / rect.width;
                const scaleY = CANVAS_SIZE / rect.height;
                const cx = (e.clientX - rect.left) * scaleX;
                const cy = (e.clientY - rect.top) * scaleY;
                const [x, y] = toLogical(cx, cy);

                if (x >= LOGICAL_MIN && x <= LOGICAL_MAX && y >= LOGICAL_MIN && y <= LOGICAL_MAX) {
                    originalPoints.push([x, y]);
                    updatePointCount();
                    updateDataTable();
                    renderCanvas0();
                }
            });

            // Toggle button handlers
            document.getElementById('btnToggleStep1').addEventListener('click', () => {
                step1Shown = !step1Shown;
                updateButtonState('btnToggleStep1', step1Shown);
                renderCanvas1();
            });

            document.getElementById('btnToggleStep2').addEventListener('click', () => {
                step2Shown = !step2Shown;
                updateButtonState('btnToggleStep2', step2Shown);
                renderCanvas2();
            });

            document.getElementById('btnToggleStep3PC1').addEventListener('click', () => {
                step3PC1Shown = !step3PC1Shown;
                updateButtonState('btnToggleStep3PC1', step3PC1Shown);
                renderCanvas3();
            });

            document.getElementById('btnToggleStep3PC2').addEventListener('click', () => {
                step3PC2Shown = !step3PC2Shown;
                updateButtonState('btnToggleStep3PC2', step3PC2Shown);
                renderCanvas3();
            });

            document.getElementById('btnToggleStep3Ellipse').addEventListener('click', () => {
                step3EllipseShown = !step3EllipseShown;
                updateButtonState('btnToggleStep3Ellipse', step3EllipseShown);
                renderCanvas3();
            });

            document.getElementById('btnToggleStep4').addEventListener('click', () => {
                step4Shown = !step4Shown;
                updateButtonState('btnToggleStep4', step4Shown);
                renderCanvas4();
            });

            document.getElementById('btnRandom').addEventListener('click', () => {
                originalPoints = generateRandom();
                updatePointCount();
                updateDataTable();
                renderCanvas0();
            });

            document.getElementById('btnCorrelated').addEventListener('click', () => {
                originalPoints = generateCorrelated();
                updatePointCount();
                updateDataTable();
                renderCanvas0();
            });

            document.getElementById('btnNegCorrelated').addEventListener('click', () => {
                originalPoints = generateNegCorrelated();
                updatePointCount();
                updateDataTable();
                renderCanvas0();
            });

            document.getElementById('btnCircular').addEventListener('click', () => {
                originalPoints = generateCircular();
                updatePointCount();
                updateDataTable();
                renderCanvas0();
            });

            document.getElementById('btnClear').addEventListener('click', resetAll);

            // Step progression buttons
            document.getElementById('btnStartStep1').addEventListener('click', () => {
                computeAllValues();
                step1Shown = false;
                updateButtonState('btnToggleStep1', false);
                renderCanvas1();
                showStep(1);
            });

            document.getElementById('btnStartStep2').addEventListener('click', () => {
                step2Shown = false;
                updateButtonState('btnToggleStep2', false);
                renderCanvas2();
                showStep(2);
            });

            document.getElementById('btnStartStep3').addEventListener('click', () => {
                step3PC1Shown = false;
                step3PC2Shown = false;
                step3EllipseShown = false;
                updateButtonState('btnToggleStep3PC1', false);
                updateButtonState('btnToggleStep3PC2', false);
                updateButtonState('btnToggleStep3Ellipse', false);
                renderCanvas3();
                showStep(3);
            });

            document.getElementById('btnStartStep4').addEventListener('click', () => {
                step4Shown = false;
                updateButtonState('btnToggleStep4', false);
                renderCanvas4();
                showStep(4);
            });

            document.getElementById('btnRestart').addEventListener('click', resetAll);

            // -----------------------------------------
            // COVARIANCE EXPLORER (Interactive Mini-Demo)
            // -----------------------------------------
            const covExplorerCanvas = document.getElementById('covExplorerCanvas');
            const covExplorerCtx = covExplorerCanvas.getContext('2d');
            const COV_SIZE = 200;
            const COV_RANGE = 6; // -3 to 3 logical range
            
            // Generate fixed sample points for the explorer (bivariate standard normal approximation)
            const explorerSamplePoints = [];
            for (let i = 0; i < 50; i++) {
                // Box-Muller for standard normal
                const u1 = Math.random(), u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
                explorerSamplePoints.push([z0, z1]);
            }
            
            function covToCanvasExplorer(x, y) {
                const cx = ((x + COV_RANGE/2) / COV_RANGE) * COV_SIZE;
                const cy = COV_SIZE - ((y + COV_RANGE/2) / COV_RANGE) * COV_SIZE;
                return [cx, cy];
            }
            
            function scaleLengthExplorer(len) {
                return (len / COV_RANGE) * COV_SIZE;
            }
            
            function drawCovExplorer() {
                const varX = parseFloat(document.getElementById('varXSlider').value);
                const varY = parseFloat(document.getElementById('varYSlider').value);
                
                // Compute valid range for covariance (positive semi-definite constraint)
                const maxCov = Math.sqrt(varX * varY);
                const covSlider = document.getElementById('covXYSlider');
                
                // Keep slider range fixed, but clamp the effective value
                // (Changing min/max dynamically causes browser step-snapping bugs)
                const rawCovXY = parseFloat(covSlider.value);
                const covXY = Math.max(-maxCov, Math.min(maxCov, rawCovXY));
                
                // Update display values
                document.getElementById('varXSliderVal').textContent = varX.toFixed(2);
                document.getElementById('varYSliderVal').textContent = varY.toFixed(2);
                
                // Show effective covariance (may be clamped)
                const covLabel = document.getElementById('covXYSliderVal');
                if (Math.abs(rawCovXY) > maxCov + 0.001) {
                    // Value is being clamped - show both
                    covLabel.innerHTML = `<span style="text-decoration: line-through; color: #999;">${rawCovXY.toFixed(2)}</span> ‚Üí ${covXY.toFixed(2)}`;
                } else {
                    covLabel.textContent = covXY.toFixed(2);
                }
                
                // Update the valid range hint
                document.getElementById('covRangeHint').textContent = 
                    `Valid range: [‚àí${maxCov.toFixed(2)}, ${maxCov.toFixed(2)}] ‚Äî variables can't co-vary more than they each vary on their own (Cov¬≤ ‚â§ Var(x)¬∑Var(y))`;
                
                // Update matrix display
                document.getElementById('covMatDisplay00').textContent = varX.toFixed(2);
                document.getElementById('covMatDisplay01').textContent = covXY.toFixed(2);
                document.getElementById('covMatDisplay10').textContent = covXY.toFixed(2);
                document.getElementById('covMatDisplay11').textContent = varY.toFixed(2);
                
                // Compute eigenvalues for this covariance matrix
                const trace = varX + varY;
                const det = varX * varY - covXY * covXY;
                const disc = Math.sqrt(Math.max(0, trace * trace / 4 - det));
                const lambda1 = trace / 2 + disc;
                const lambda2 = trace / 2 - disc;
                
                // Compute eigenvector for lambda1
                let v1x, v1y;
                if (Math.abs(covXY) > 1e-10) {
                    v1x = lambda1 - varY;
                    v1y = covXY;
                } else if (varX >= varY) {
                    v1x = 1; v1y = 0;
                } else {
                    v1x = 0; v1y = 1;
                }
                const norm = Math.sqrt(v1x * v1x + v1y * v1y);
                v1x /= norm; v1y /= norm;
                
                const rotation = Math.atan2(v1y, v1x);
                const a = Math.sqrt(lambda1) * 2; // 2 sigma
                const b = Math.sqrt(lambda2) * 2;
                
                // Clear and draw background
                covExplorerCtx.clearRect(0, 0, COV_SIZE, COV_SIZE);
                covExplorerCtx.fillStyle = '#fafafa';
                covExplorerCtx.fillRect(0, 0, COV_SIZE, COV_SIZE);
                
                // Draw light grid
                covExplorerCtx.strokeStyle = '#e8e8e8';
                covExplorerCtx.lineWidth = 1;
                for (let i = -2; i <= 2; i++) {
                    const [vx] = covToCanvasExplorer(i, 0);
                    covExplorerCtx.beginPath();
                    covExplorerCtx.moveTo(vx, 0);
                    covExplorerCtx.lineTo(vx, COV_SIZE);
                    covExplorerCtx.stroke();
                    
                    const [, hy] = covToCanvasExplorer(0, i);
                    covExplorerCtx.beginPath();
                    covExplorerCtx.moveTo(0, hy);
                    covExplorerCtx.lineTo(COV_SIZE, hy);
                    covExplorerCtx.stroke();
                }
                
                // Draw axes
                covExplorerCtx.strokeStyle = '#bbb';
                covExplorerCtx.lineWidth = 1;
                const [cx, cy] = covToCanvasExplorer(0, 0);
                covExplorerCtx.beginPath();
                covExplorerCtx.moveTo(0, cy);
                covExplorerCtx.lineTo(COV_SIZE, cy);
                covExplorerCtx.stroke();
                covExplorerCtx.beginPath();
                covExplorerCtx.moveTo(cx, 0);
                covExplorerCtx.lineTo(cx, COV_SIZE);
                covExplorerCtx.stroke();
                
                // Transform and draw sample points
                // For a covariance matrix Œ£ = [[varX, covXY], [covXY, varY]]
                // We need to find L such that L*L^T = Œ£ (Cholesky decomposition)
                // L = [[sqrt(varX), 0], [covXY/sqrt(varX), sqrt(varY - covXY^2/varX)]]
                const L00 = Math.sqrt(varX);
                const L10 = covXY / L00;
                const L11Sq = varY - covXY * covXY / varX;
                const L11 = Math.sqrt(Math.max(0, L11Sq));
                
                // Draw transformed points
                covExplorerCtx.fillStyle = 'rgba(52, 152, 219, 0.6)';
                explorerSamplePoints.forEach(([z0, z1]) => {
                    // Transform: [x, y] = L * [z0, z1]
                    const x = L00 * z0;
                    const y = L10 * z0 + L11 * z1;
                    const [px, py] = covToCanvasExplorer(x, y);
                    if (px >= 0 && px <= COV_SIZE && py >= 0 && py <= COV_SIZE) {
                        covExplorerCtx.beginPath();
                        covExplorerCtx.arc(px, py, 3, 0, Math.PI * 2);
                        covExplorerCtx.fill();
                    }
                });
                
                // Draw ellipse
                const canvasA = scaleLengthExplorer(a);
                const canvasB = scaleLengthExplorer(b);
                
                covExplorerCtx.save();
                covExplorerCtx.translate(cx, cy);
                covExplorerCtx.rotate(-rotation);
                
                covExplorerCtx.strokeStyle = '#9b59b6';
                covExplorerCtx.lineWidth = 2;
                covExplorerCtx.setLineDash([4, 3]);
                covExplorerCtx.beginPath();
                covExplorerCtx.ellipse(0, 0, canvasA, canvasB, 0, 0, Math.PI * 2);
                covExplorerCtx.stroke();
                
                covExplorerCtx.fillStyle = 'rgba(155, 89, 182, 0.08)';
                covExplorerCtx.beginPath();
                covExplorerCtx.ellipse(0, 0, canvasA, canvasB, 0, 0, Math.PI * 2);
                covExplorerCtx.fill();
                
                covExplorerCtx.setLineDash([]);
                covExplorerCtx.restore();
                
                // Draw PC axes (short vectors from center)
                const pcScale = 1.5;
                const pc1Len = Math.sqrt(lambda1) * pcScale;
                const pc2Len = Math.sqrt(lambda2) * pcScale;
                
                // PC1 (red)
                const [pc1x, pc1y] = covToCanvasExplorer(v1x * pc1Len, v1y * pc1Len);
                covExplorerCtx.strokeStyle = '#e74c3c';
                covExplorerCtx.lineWidth = 2;
                covExplorerCtx.beginPath();
                covExplorerCtx.moveTo(cx, cy);
                covExplorerCtx.lineTo(pc1x, pc1y);
                covExplorerCtx.stroke();
                
                // PC2 (purple) - perpendicular to PC1
                const v2x = -v1y, v2y = v1x;
                const [pc2x, pc2y] = covToCanvasExplorer(v2x * pc2Len, v2y * pc2Len);
                covExplorerCtx.strokeStyle = '#9b59b6';
                covExplorerCtx.lineWidth = 2;
                covExplorerCtx.beginPath();
                covExplorerCtx.moveTo(cx, cy);
                covExplorerCtx.lineTo(pc2x, pc2y);
                covExplorerCtx.stroke();
                
                // Update info text
                const infoEl = document.getElementById('covExplorerInfo');
                const correlation = covXY / Math.sqrt(varX * varY);
                let info = '';
                
                if (Math.abs(correlation) < 0.1) {
                    if (Math.abs(varX - varY) < 0.2) {
                        info = 'Equal variances, no correlation ‚Üí circular distribution';
                    } else if (varX > varY) {
                        info = 'No correlation, but wider horizontally ‚Üí axis-aligned ellipse';
                    } else {
                        info = 'No correlation, but wider vertically ‚Üí axis-aligned ellipse';
                    }
                } else if (correlation > 0) {
                    info = `Positive correlation (r=${correlation.toFixed(2)}) ‚Üí tilted upward ‚Üó`;
                } else {
                    info = `Negative correlation (r=${correlation.toFixed(2)}) ‚Üí tilted downward ‚Üò`;
                }
                
                const varExplained = (lambda1 / (lambda1 + lambda2) * 100).toFixed(0);
                info += ` | PC1 explains ${varExplained}%`;
                
                infoEl.textContent = info;
            }
            
            // Event listeners for sliders
            document.getElementById('varXSlider').addEventListener('input', drawCovExplorer);
            document.getElementById('varYSlider').addEventListener('input', drawCovExplorer);
            document.getElementById('covXYSlider').addEventListener('input', drawCovExplorer);

            // -----------------------------------------
            // INITIALIZATION
            // -----------------------------------------
            function init() {
                for (let key in contexts) {
                    drawGrid(contexts[key]);
                }
                // Initialize covariance explorer
                drawCovExplorer();
            }

            init();
        })();
    </script>
</body>
</html>
